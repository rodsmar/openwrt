From a1da16a0e8de7d47d6dbd43e2e677edd6285387a Mon Sep 17 00:00:00 2001
From: "sujuan.chen" <sujuan.chen@mediatek.com>
Date: Mon, 11 Sep 2023 17:57:32 +0800
Subject: [PATCH 2011/2015] wifi: mt76: mt7915: wed: change wed token init size
 to adapt wed version

Signed-off-by: sujuan.chen <sujuan.chen@mediatek.com>
---
 mt76.h          |  2 ++
 mt7915/mac.c    | 10 ++++++++--
 mt7915/mcu.c    |  7 +++++--
 mt7915/mmio.c   |  9 ++++++---
 mt7915/mt7915.h |  4 +++-
 tx.c            | 23 +++++++----------------
 wed.c           |  4 ++--
 7 files changed, 33 insertions(+), 26 deletions(-)

--- a/mt76.h
+++ b/mt76.h
@@ -35,6 +35,8 @@
 
 #define MT76_BUILD_TIME_LEN	24
 
+#define MT76_WED_SW_TOKEN_SIZE	1024
+
 #define MT_QFLAG_WED_RING	GENMASK(1, 0)
 #define MT_QFLAG_WED_TYPE	GENMASK(4, 2)
 #define MT_QFLAG_WED		BIT(5)
--- a/mt7915/mac.c
+++ b/mt7915/mac.c
@@ -929,7 +929,7 @@ mt7915_mac_tx_free(struct mt7915_dev *de
 	v3 = (FIELD_GET(MT_TX_FREE_VER, txd) == 0x4);
 
 	for (cur_info = tx_info; count < total; cur_info++) {
-		u32 msdu, info;
+		u32 msdu, info, max_token_size = MT7915_TOKEN_SIZE;
 		u8 i;
 
 		if (WARN_ON_ONCE((void *)cur_info >= end))
@@ -973,6 +973,12 @@ mt7915_mac_tx_free(struct mt7915_dev *de
 			wcid->stats.tx_failed += tx_failed;
 		}
 
+		if (mtk_wed_device_active(&mdev->mmio.wed))
+			max_token_size = (is_mt7915(&dev->mt76) ?
+					  MT7915_WED_TOKEN_SIZE_V0 :
+					  MT7915_WED_TOKEN_SIZE) +
+					 MT7915_WED_SW_TOKEN_SIZE;
+
 		if (v3 && (info & MT_TX_FREE_MPDU_HEADER_V3))
 			continue;
 
--- a/mt7915/mcu.c
+++ b/mt7915/mcu.c
@@ -2467,6 +2467,9 @@ mt7915_mcu_init_rx_airtime(struct mt7915
 static int mt7915_red_set_watermark(struct mt7915_dev *dev)
 {
 #define RED_GLOBAL_TOKEN_WATERMARK 2
+	u16 token_size = is_mt7915(&dev->mt76) ?
+			 MT7915_WED_TOKEN_SIZE_V0 :
+			 MT7915_WED_TOKEN_SIZE;
 	struct {
 		__le32 args[3];
 		u8 cmd;
@@ -2480,8 +2483,8 @@ static int mt7915_red_set_watermark(stru
 		.args[0] = cpu_to_le32(MCU_WA_PARAM_RED_SETTING),
 		.cmd = RED_GLOBAL_TOKEN_WATERMARK,
 		.len = cpu_to_le16(sizeof(req) - sizeof(req.args)),
-		.high_mark = cpu_to_le16(MT7915_HW_TOKEN_SIZE - 256),
-		.low_mark = cpu_to_le16(MT7915_HW_TOKEN_SIZE - 256 - 1536),
+		.high_mark = cpu_to_le16(token_size - 256),
+		.low_mark = cpu_to_le16(token_size - 256 - 1536),
 	};
 
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_PARAM_CMD(SET), &req,
--- a/mt7915/mmio.c
+++ b/mt7915/mmio.c
@@ -700,11 +700,14 @@ int mt7915_mmio_wed_init(struct mt7915_d
 		wed->wlan.wpdma_rx_glo = res->start + MT_WPDMA_GLO_CFG;
 		wed->wlan.wpdma_rx = res->start + MT_RXQ_WED_DATA_RING_BASE;
 	}
-	wed->wlan.nbuf = MT7915_HW_TOKEN_SIZE;
+
+	wed->wlan.nbuf = is_mt7915(&dev->mt76) ?
+			 MT7915_WED_TOKEN_SIZE_V0 :
+			 MT7915_WED_TOKEN_SIZE;
 	wed->wlan.tx_tbit[0] = is_mt7915(&dev->mt76) ? 4 : 30;
 	wed->wlan.tx_tbit[1] = is_mt7915(&dev->mt76) ? 5 : 31;
 	wed->wlan.txfree_tbit = is_mt798x(&dev->mt76) ? 2 : 1;
-	wed->wlan.token_start = MT7915_TOKEN_SIZE - wed->wlan.nbuf;
+	wed->wlan.token_start = 0;
 	wed->wlan.wcid_512 = !is_mt7915(&dev->mt76);
 
 	wed->wlan.rx_nbuf = 65536;
@@ -737,7 +740,7 @@ int mt7915_mmio_wed_init(struct mt7915_d
 
 	*irq = wed->irq;
 	dev->mt76.dma_dev = wed->dev;
-	dev->mt76.token_size = wed->wlan.token_start;
+	dev->mt76.token_size = MT7915_WED_SW_TOKEN_SIZE;
 
 	ret = dma_set_mask(wed->dev, DMA_BIT_MASK(32));
 	if (ret)
--- a/mt7915/mt7915.h
+++ b/mt7915/mt7915.h
@@ -62,7 +62,9 @@
 #define MT7916_EEPROM_SIZE		4096
 
 #define MT7915_EEPROM_BLOCK_SIZE	16
-#define MT7915_HW_TOKEN_SIZE		7168
+#define MT7915_WED_TOKEN_SIZE		8192
+#define MT7915_WED_TOKEN_SIZE_V0	7168
+#define MT7915_WED_SW_TOKEN_SIZE	1024
 #define MT7915_TOKEN_SIZE		8192
 
 #define MT7915_CFEND_RATE_DEFAULT	0x49	/* OFDM 24M */
--- a/tx.c
+++ b/tx.c
@@ -850,7 +850,7 @@ int mt76_token_consume(struct mt76_dev *
 		       u8 phy_idx)
 {
 	struct mt76_phy *phy = phy_idx < __MT_MAX_BAND ? dev->phys[phy_idx] : NULL;
-	int token;
+	int token, start = 0;
 
 	spin_lock_bh(&dev->token_lock);
 
@@ -860,8 +860,12 @@ int mt76_token_consume(struct mt76_dev *
 		return -EINVAL;
 	}
 
-	token = idr_alloc(&dev->token, *ptxwi, 0, dev->token_size, GFP_ATOMIC);
-	if (token >= 0) {
+	if (mtk_wed_device_active(&dev->mmio.wed))
+		start = dev->mmio.wed.wlan.nbuf;
+
+	token = idr_alloc(&dev->token, *ptxwi, start, start + dev->token_size,
+			  GFP_ATOMIC);
+	if (token >= start) {
 		dev->token_count++;
 
 		if (dev->num_phy > 1 && phy) {
@@ -870,12 +874,6 @@ int mt76_token_consume(struct mt76_dev *
 		}
 	}
 
-#ifdef CONFIG_NET_MEDIATEK_SOC_WED
-	if (mtk_wed_device_active(&dev->mmio.wed) &&
-	    token >= dev->mmio.wed.wlan.token_start)
-		dev->wed_token_count++;
-#endif
-
 	if (dev->token_count >= dev->token_size - MT76_TOKEN_FREE_THR)
 		__mt76_set_tx_blocked(dev, true);
 
@@ -915,13 +913,6 @@ mt76_token_release(struct mt76_dev *dev,
 		dev->token_count--;
 		if (dev->num_phy > 1 && dev->phys[txwi->phy_idx])
 			dev->phys[txwi->phy_idx]->tokens--;
-
-#ifdef CONFIG_NET_MEDIATEK_SOC_WED
-		if (mtk_wed_device_active(&dev->mmio.wed) &&
-		    token >= dev->mmio.wed.wlan.token_start &&
-		    --dev->wed_token_count == 0)
-			wake_up(&dev->tx_wait);
-#endif
 	}
 
 	if (dev->token_count < dev->token_size - MT76_TOKEN_FREE_THR &&
--- a/wed.c
+++ b/wed.c
@@ -83,7 +83,7 @@ int mt76_wed_offload_enable(struct mtk_w
 	struct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);
 
 	spin_lock_bh(&dev->token_lock);
-	dev->token_size = wed->wlan.token_start;
+	dev->token_size = MT76_WED_SW_TOKEN_SIZE;
 	spin_unlock_bh(&dev->token_lock);
 
 	return !wait_event_timeout(dev->tx_wait, !dev->wed_token_count, HZ);
@@ -167,7 +167,7 @@ void mt76_wed_offload_disable(struct mtk
 	struct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);
 
 	spin_lock_bh(&dev->token_lock);
-	dev->token_size = wed->wlan.token_start;
+	dev->token_size = MT76_WED_SW_TOKEN_SIZE;
 	spin_unlock_bh(&dev->token_lock);
 }
 EXPORT_SYMBOL_GPL(mt76_wed_offload_disable);
